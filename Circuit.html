<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>电路</title>
<script src="https://libs.baidu.com/jquery/1.11.3/jquery.min.js"></script>
<style>
canvas {
	background:#FFFFFF;
	display:block;
	margin:0 auto;
}
#controls {
	width:200px;
	height:100%;
	position:absolute;
	left:0;
	top:0;
	background:linear-gradient(to bottom,#000000,#b8b8b8);
	user-select:none;
}
#controls section {
	margin-top:10px;
	height:20px;
}
#controls .label {
	width:50%;
	height:20px;
	line-height:20px;
	text-align:center;
	color:#FFF;
	display:block;
	float:left;
}
#xing {
	float:right;
	width:50%;
	height:20px;
}
/*#shape {
	*/
        /*width:50%;
	height:20px;
	display:block;
	*/
        /*
}
*/
        #controls .color {
	width:50%;
	height:auto;
	float:right;
}
#colors input {
	float:right;
	width:48%;
	height:20px;
	border:none;
}
#widths input {
	float:right;
	width:49%;
	height:20px;
	border:none;
}
#style {
	float:right;
	width:49%;
	height:20px;
	border:none;
}
input[type=button] {
	width:150px;
	height:30px;
	background:#C40000;
	color:#FFF;
	border-radius:5px;
	margin-top:10px;
	margin-left:10px;
	border:none;
	display:block;
}
</style>
</head>
<body>
<img id="switch1" src="/img/Switch1.jpg" alt="Switch1" style='display:none' />
<img id="switch2" src="/img/Switch2.jpg" alt="Switch2" style='display:none' />
<canvas width="500" height="500"></canvas>
<div id="controls">

    <input type="button" value="绘画" id="drawbutton">

</div>

<script>
 var verticalLines = [];   //必须设置的变量，用于保存已画的竖线
 var horizontalLines = [];//必须设置的变量，用于保存已画的水平线
 var data = null;//必须设置的变量，用于保存canvas
 var draws = [];//必须设置的变量，用于保存电路中的线路和元件
 
 var canvas = document.querySelector("canvas");
 var cobj = canvas.getContext("2d");

 var drawbutton = document.querySelector("#drawbutton");




 canvas.onmousemove = function(e) {
     var ox = e.offsetX;
     var oy = e.offsetY;
	 if(data!=null)
	 {
		cobj.putImageData(data, 0, 0, 0, 0, 500, 500); // 由canvas的大小设置参数
		for(var i=0;i<draws.length;i++)
		{
			if(draws[i].tipcallback!=null)
			{
			    if(draws[i].checkselected(ox,oy)==1)
				    draws[i].drawToolTip( ox, oy);
			}
		}
		
	 }
 
 };
 
 drawbutton.onclick = function() {
     myCircuit();
 };

 function draw1Tipcallback(){
     var ret = "draw1";
	 return ret;
 }
 function draw2Tipcallback(){
     var ret = "draw2";
	 return ret;
 }
 function draw3Tipcallback(){
     var ret = "draw3";
	 return ret;
 }
 
 function myCircuit() {  //由线路、元件组合电路图
	var switch1=document.getElementById("switch1");
    var draw1 = new Draw(cobj, {
        color: "#000",tipcallback:draw1Tipcallback
     });
	draws.push(draw1);
	var switch1_loc = draw1.component_switch1(switch1,10,10,60,128);
	var ox1=switch1_loc.x_1_bottom;
	var oy1=switch1_loc.y_1_bottom;
	var ox2=switch1_loc.x_2_bottom;
	var oy2=switch1_loc.y_2_bottom;	
	var draw2 = new Draw(cobj, {
        color: "#FF0000",tipcallback:draw2Tipcallback
     });
	draws.push(draw2); 
	draw2.vertical_line(ox1,oy1,200);
	draw2.horizontal_line(ox1,oy1+200-0.5,300); //-3的原因是线的宽度为6，这样可以对齐
	draw2.vertical_line(ox1+200,oy1,200-0.5); //-3的原因是线的宽度为6，这样可以对齐
	var draw3 = new Draw(cobj, {
        color: "#000",tipcallback:draw3Tipcallback
     });	
	draws.push(draw3);  
	draw3.vertical_line(ox2,oy2,300);
	var draw4 = new Draw(cobj, {
        color: "#000",tipcallback:null
     });	
	draws.push(draw4); 
	draw4.horizontal_line(0,250,300);
	
	data=cobj.getImageData(0, 0, 500, 500) // 由canvas的大小设置参数
}

 class Draw {
     constructor(cobj, option) {
         this.cobj = cobj;
         this.color = option.color;
		 this.tipcallback = option.tipcallback;
		 this.style = "stroke";
         this.width = 1;
		 this.drawarea = [];
         
     }
     init() { //初始化
         this.cobj.strokeStyle = this.color;
         this.cobj.fillStyle = this.color;
         this.cobj.lineWidth = this.width;
     }
	 checkselected(ox,oy) 
	 {
		for(var i=0;i<this.drawarea.length;i++)
		{
			if((this.drawarea[i].left_top_x<ox)&&(this.drawarea[i].right_bottom_x>ox)&&(this.drawarea[i].left_top_y<oy)&&(this.drawarea[i].right_bottom_y>oy))
				return 1;
		}
		return 0;
	 }
	 // 开关图片1上下各两个接线位置，根据原始图片大小、显示图片大小计算出接线位置
	 //switch1.jpg 原始图片大小 150*326, 左接线位置x:40；右接线位置x:106
     // ox, oy, w, h分别为左上角起点x，y和图片的显示宽，高
     // 返回的是配电箱上下成对的接线坐标
	 component_switch1(img,ox,oy,w,h)
	 {
		var area = {left_top_x:ox,left_top_y:oy,right_bottom_x:ox+w,right_bottom_y:oy+h};
		this.drawarea.push(area);
		this.cobj.drawImage(img,ox,oy,w,h);
		var x_1_top = Math.floor(w*40/150)+ox;
		var y_1_top = oy;
		var x_2_top = Math.floor(w*106/150)+ox;
		var y_2_top = oy;
		var x_1_bottom = Math.floor(w*40/150)+ox;
		var y_1_bottom = oy+h;
		var x_2_bottom = Math.floor(w*106/150)+ox;
		var y_2_bottom = oy+h;
		var ret= {x_1_top:x_1_top,y_1_top:y_1_top,x_2_top:x_2_top,y_2_top:y_2_top,
		x_1_bottom:x_1_bottom,y_1_bottom:y_1_bottom,x_2_bottom:x_2_bottom,y_2_bottom:y_2_bottom};
		return ret;
	 }

	 // 起点 + 长度
	 vertical_line(ox,oy,len) {
	    var vline = {sx : ox, sy : oy, ex : ox,ey : oy+len};
		verticalLines.push(vline);
		var area = {left_top_x:ox-3,left_top_y:oy,right_bottom_x:ox+3,right_bottom_y:oy+len};
		this.drawarea.push(area);
		var intersectPoints = [];
		// 判断与水平线相交
		for(var i=0;i<horizontalLines.length;i++)
		{
		    if((horizontalLines[i].sx<vline.sx)&&(horizontalLines[i].ex>vline.ex)&&(horizontalLines[i].sy>vline.sy)&&(horizontalLines[i].ey<vline.ey))
			{
				var point = {x:vline.sx,y:horizontalLines[i].sy};
				intersectPoints.push(point);
			}
		}
		//对交点排序		
		for(var i=0;i<intersectPoints.length;i++)
		{
		    var minpoint=intersectPoints[i].y;
			for(var j=i+1;j<intersectPoints.length;j++)
			{
				if(intersectPoints[j].y<minpoint)
				{
				    var tmp=intersectPoints[j];
					minpoint=intersectPoints[j].y;
					intersectPoints[j]=intersectPoints[i];
					intersectPoints[i]=tmp;
				}
			}
		}
		// 直线的终点
		var point = {x:vline.ex,y:vline.ey};
		intersectPoints.push(point);
		this.init();
        this.cobj.beginPath();
		var lastPoint= {x:vline.sx,y:vline.sy};
		for(var i=0;i<intersectPoints.length;i++)
		{
			this.cobj.moveTo(lastPoint.x, lastPoint.y);
			if(i==intersectPoints.length-1)
			{
				this.cobj.lineTo(intersectPoints[i].x, intersectPoints[i].y);
			}
			else {
				this.cobj.lineTo(intersectPoints[i].x, intersectPoints[i].y-3);
				this.cobj.arc(intersectPoints[i].x, intersectPoints[i].y, 3, Math.PI*3 / 2, Math.PI/ 2, false);
				lastPoint= {x:intersectPoints[i].x, y:intersectPoints[i].y+3};
			}
		
		}
		this.cobj.stroke();
		 
	 }
	 horizontal_line(ox,oy,len) {
	    var hline = {sx : ox, sy : oy, ex : ox+len,ey : oy};
		horizontalLines.push(hline);
		var area = {left_top_x:ox,left_top_y:oy-3,right_bottom_x:ox+len,right_bottom_y:oy+3};
		this.drawarea.push(area);
		var intersectPoints = [];
		// 判断与垂线相交
		for(var i=0;i<verticalLines.length;i++)
		{
		    if((verticalLines[i].sx>hline.sx)&&(verticalLines[i].ex<hline.ex)&&(verticalLines[i].sy<hline.sy)&&(verticalLines[i].ey>hline.ey))
			{
				var point = {x:verticalLines[i].sx,y:hline.sy};
				intersectPoints.push(point);
			}
		}
		//对交点排序		
		for(var i=0;i<intersectPoints.length;i++)
		{
		    var minpoint=intersectPoints[i].x;
			for(var j=i+1;j<intersectPoints.length;j++)
			{
				if(intersectPoints[j].x<minpoint)
				{
				    var tmp=intersectPoints[j];
					minpoint=intersectPoints[j].x;
					intersectPoints[j]=intersectPoints[i];
					intersectPoints[i]=tmp;
				}
			}
		}
		// 直线的终点
		var point = {x:hline.ex,y:hline.ey};
		intersectPoints.push(point);
		this.init();
        this.cobj.beginPath();
		var lastPoint= {x:hline.sx,y:hline.sy};
		for(var i=0;i<intersectPoints.length;i++)
		{
			this.cobj.moveTo(lastPoint.x, lastPoint.y);
			if(i==intersectPoints.length-1)
			{
				this.cobj.lineTo(intersectPoints[i].x, intersectPoints[i].y);
			}
			else {
				this.cobj.lineTo(intersectPoints[i].x-3, intersectPoints[i].y);
				this.cobj.arc(intersectPoints[i].x, intersectPoints[i].y, 3, Math.PI, 0, false);
				lastPoint= {x:intersectPoints[i].x+3, y:intersectPoints[i].y};
			}
		
		}
		this.cobj.stroke(); 
	 }
     // 鼠标move操作
	 drawToolTip(x, y) {
		if(this.tipcallback!=null)
		{
			this.cobj.save();
			var padding = 3;
			var font = "16px arial";
			var txtLoc=this.tipcallback();
			this.cobj.font = font;
			this.cobj.textBaseline = 'bottom';
			this.cobj.fillStyle = 'yellow';
 
			//绘制ToolTip背景
			var width = this.cobj.measureText(txtLoc).width;
			var height = parseInt(font, 10);
			this.cobj.fillRect(x, y-height, width+padding*2, height+padding*2);
 
			//绘制ToolTip文字
			this.cobj.fillStyle = '#000';
			this.cobj.fillText(txtLoc, x+padding, y+padding);
 
			this.cobj.restore();
		}
    }
 }
</script>

</body>
</html>
